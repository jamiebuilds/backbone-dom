{"version":3,"sources":["/Users/thejameskyle/git/marionette/backbone-dom/src/backbone-dom.js"],"names":[],"mappings":"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","file":"backbone-dom.min.js","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['backbone', 'underscore', 'backbone-metal'], factory);\n  } else if (typeof exports !== 'undefined') {\n    module.exports = factory(require('backbone'), require('underscore'), require('backbone-metal'));\n  } else {\n    factory(root.Backbone, root._, root.Backbone.Metal);\n  }\n})(this, function(Backbone, _, Metal) {\n  'use strict';\n\n  var _slice = Array.prototype.slice;\n\n  /**\n   * @module DOM\n   */\n  var DOM = Backbone.DOM = {};\n  \n  /**\n   * A subclass of Metal.Error for use in Backbone Views.\n   *\n   * @example\n   * throw new DOM.Error('Why must I cry?');\n   * // >> ViewError: Why must I cry?\n   * // >>   [stack trace]\n   *\n   * @class Error\n   * @memberOf DOM\n   * @extends Metal.Error\n   */\n  var Err = DOM.Error = Metal.Error.extend({\n    name: 'ViewError',\n    urlRoot: 'http://github.com/thejameskyle/backbone-dom'\n  });\n  \n  /**\n   * These are provided as a place to override DOM's usage of native methods with\n   * your own methods.\n   *\n   * @name utils\n   * @memberOf DOM\n   */\n  var utils = DOM.utils = {\n  \n    /**\n     * Get the parent node of an element.\n     *\n     * @public\n     * @method parentNode\n     * @memberOf DOM.utils\n     * @param {Node} node - The element to look up the parent from.\n     * @return {Node} - The parent node.\n     */\n    parentNode(node) {\n      return node.parentNode;\n    },\n  \n    /**\n     * Get the next sibling node of an element.\n     *\n     * @example\n     * document.body;\n     * // >> <body><div></div><span></span></body>\n     *\n     * document.body.children[0]\n     * // >> <div></div>\n     *\n     * utils.nextSibling(document.body.children[0]);\n     * // >> <span></span>\n     *\n     * @public\n     * @method nextSibling\n     * @memberOf DOM.utils\n     * @param {Node} node - The element to look up the next sibling from.\n     * @return {Node} - The next sibling.\n     */\n    nextSibling(node) {\n      return node.nextSibling;\n    },\n  \n    /**\n     * Insert an element inside a parent node before a next sibling node.\n     *\n     * @example\n     * document.body;\n     * // >> <body><span></span></body>\n     *\n     * utils.insertBefore(document.body, document.createElement('div'), document.body.children[0]);\n     * // >> <div></div>\n     *\n     * document.body;\n     * // >> <body><div></div><span></span></body>\n     *\n     * @public\n     * @method insertBefore\n     * @memberOf DOM.utils\n     * @param {Node} parentNode - The node to insert inside.\n     * @param {Node} node - The node to insert.\n     * @param {Node} nextSibling - The node to insert before.\n     * @return {Node} - The inserted node.\n     */\n    insertBefore(parentNode, node, nextSibling) {\n      return parentNode.insertBefore(node, nextSibling);\n    },\n  \n    /**\n     * Append a node to a parent node.\n     *\n     * @example\n     * utils.appendChild(document.body, document.createElement('div'));\n     * // >> <div></div>\n     *\n     * document.body;\n     * // <body><div></div></body>\n     *\n     * @public\n     * @method appendChild\n     * @memberOf DOM.utils\n     * @param {Node} parentNode - The node to append inside.\n     * @param {Node} node - The node to append.\n     * @return {Node} - The appended node.\n     */\n    appendChild(parentNode, node) {\n      return parentNode.appendChild(node);\n    },\n  \n    /**\n     * Get or set the innerHTML of a DOM element.\n     *\n     * If you specify `html` it will be used as a setter, otherwise it will be\n     * used as a getter.\n     *\n     * @example\n     * utils.innerHTML(document.body);\n     * // >> ''\n     *\n     * utils.innerHTML(document.body, 'Hello World!');\n     * // >> 'Hello World!'\n     *\n     * utils.innerHTML(document.body);\n     * // >> 'Hello World!'\n     *\n     * @public\n     * @method innerHTML\n     * @memberOf DOM.utils\n     * @param {Node} node - The node to get/set inner html.\n     * @param {String} [html] - The html to set the node's inner html to.\n     * @return {String} - The inner html of the node.\n     */\n    innerHTML(node, html) {\n      if (html) {\n        return (node.innerHTML = html);\n      } else {\n        return node.innerHTML;\n      }\n    },\n  \n    /**\n     * Remove an element from the DOM.\n     *\n     * @example\n     * document.body;\n     * // >> <body><div></div></body>\n     *\n     * utils.remove(document.body.children[0]);\n     *\n     * document.body;\n     * // >> <body></body>\n     *\n     * @public\n     * @method remove\n     * @memberOf DOM.utils\n     * @param {Node} node - The node to remove.\n     */\n    remove(node) {\n      if (node.remove) {\n        node.remove();\n      } else {\n        var parentNode = utils.parentNode(node);\n        parentNode.removeChild(node);\n      }\n    }\n  };\n  \n  /**\n   * Creates a new View.\n   *\n   * @example\n   * var MyView = View.extend({\n   *   template: _.template('Hello <%= location %>!'),\n   *   initialize() {\n   *     console.log(this.$el.html());\n   *   }\n   * });\n   *\n   * new MyView({\n   *   model: new Backbone.Model({ location: 'World' })\n   * });\n   * // >> Hello World!\n   *\n   * @public\n   * @class View\n   * @memberOf DOM\n   */\n  var View = DOM.View = Backbone.View.extend({\n  \n    constructor(options = {}) {\n      if (options.template) {\n        this.template = options.template;\n      }\n      this._super.apply(this, arguments);\n    },\n  \n    /**\n     * Compile the template with data.\n     *\n     * @public\n     * @instance\n     * @abstact\n     * @method compile\n     * @memberOf DOM.View\n     * @return {String} - The compiled template.\n     */\n    compile() {\n      if (!this.template) {\n        return;\n      }\n  \n      // Get data for template.\n      var data = this.serializeData();\n  \n      // Compile template.\n      return this.template(data);\n    },\n  \n    /**\n     * Render template with data, or update existing DOM.\n     *\n     * @public\n     * @instance\n     * @method render\n     * @memberOf DOM.View\n     * @fires DOM.View#before:render\n     * @fires DOM.View#render\n     * @throws {ViewError} - cannot call this method on a destroyed view.\n     * @return {Object} - this\n     */\n    render() {\n      // Immediately throw an error if attempting to render a view that has been\n      // destroyed.\n      if (this._isDestroyed) {\n        throw new Err('Views cannot be rendered after they have been destroyed.');\n      }\n  \n      /**\n       * @event DOM.View#before:render\n       */\n      this.triggerMethod('before:render');\n  \n      var html = this.compile();\n  \n      // Avoid re-rendering when it will result in the same html.\n      if (html === utils.innerHTML(this.el)) {\n        return this;\n      }\n  \n      // Store current position so it can be re-attached to the same location.\n      var parentNode = utils.parentNode(this.el);\n      var nextSibling = utils.nextSibling(this.el);\n  \n      // Detach only when view is currently in DOM.\n      if (parentNode && this._isAttached) {\n        this.detach();\n      }\n  \n      // Insert new DOM.\n      utils.innerHTML(this.el, html);\n  \n      // Attach only when it was previously in the DOM.\n      if (parentNode && !this._isAttached) {\n        this.attach(parentNode, nextSibling);\n      }\n  \n      // Mark the view as rendered.\n      this._isRendered = true;\n  \n      /**\n       * @event DOM.View#render\n       */\n      this.triggerMethod('render');\n  \n      return this;\n    },\n  \n    /**\n     * Add `el` to a particular location in DOM.\n     *\n     * @public\n     * @instance\n     * @method attach\n     * @memberOf DOM.View\n     * @param {Element} parentNode\n     * @param {Element} [nextSibling]\n     * @fires DOM.View#before:attach\n     * @fires DOM.View#attach\n     * @throws {ViewError} - cannot call this method on a destroyed view.\n     * @return {Object} - this\n     */\n    attach(parentNode, nextSibling) {\n      // Immediately throw an error if attempting to attach a view that has been\n      // destroyed.\n      if (this._isDestroyed) {\n        throw new Err('Views cannot be attached after they have been destroyed.');\n      }\n  \n      /**\n       * @event DOM.View#before:attach\n       */\n      this.triggerMethod('before:attach');\n  \n      // Don't attach if view is already attached.\n      if (this._isAttached) {\n        return this;\n      }\n  \n      // If there is a next sibling node, insert it before that sibling,\n      // otherwise append it to the parent node.\n      if (nextSibling) {\n        utils.insertBefore(parentNode, this.el, nextSibling);\n      } else {\n        utils.appendChild(parentNode, this.el);\n      }\n  \n      // Mark the view as attached.\n      this._isAttached = true;\n  \n      /**\n       * @event DOM.View#attach\n       */\n      this.triggerMethod('attach');\n  \n      return this;\n    },\n  \n    /**\n     * Remove `el` from DOM.\n     *\n     * @public\n     * @instance\n     * @method detach\n     * @memberOf DOM.View\n     * @fires DOM.View#before:detach\n     * @fires DOM.View#detach\n     * @throws {ViewError} - cannot call this method on a destroyed view.\n     * @return {Object} - this\n     */\n    detach() {\n      // Immediately throw an error if attempting to detach a view that has been\n      // destroyed.\n      if (this._isDestroyed) {\n        throw new Err('Views cannot be detached after they have been destroyed.');\n      }\n  \n      /**\n       * @event DOM.View#before:attach\n       */\n      this.triggerMethod('before:detach');\n  \n      // Don't detach if view is not attached.\n      if (!this._isAttached) {\n        return this;\n      }\n  \n      // Remove the element from the DOM.\n      utils.remove(this.el);\n  \n      // Mark the view as detached\n      this._isAttached = false;\n  \n      /**\n       * @event DOM.View#detach\n       */\n      this.triggerMethod('detach');\n  \n      return this;\n    },\n  \n    /**\n     * Permanently destroy a View preventing it from ever getting rendered again.\n     *\n     * @public\n     * @instance\n     * @method destroy\n     * @memberOf DOM.View\n     * @throws {ViewError} - cannot call this method on an already destroyed view.\n     * @return {Object} - this\n     */\n    destroy() {\n      // Immediately throw an error if the view has already been destroyed\n      if (this._isDestroyed) {\n        throw new Err('Views cannot be destroyed more than once.');\n      }\n  \n      /**\n       * @event DOM.View#before:destroy\n       */\n      this.triggerMethod('before:destroy');\n  \n      // Remove the view from the DOM.\n      this.detach(this.el);\n  \n      // Ensure the view is empty.\n      utils.innerHTML(this.el, '');\n  \n      // Remove any event listeners.\n      this.stopListening();\n  \n      // Attempt to remove DOM nodes from the instance.\n      delete this.el;\n      delete this.$el;\n  \n      // Mark the view as not rendered.\n      this._isRendered = false;\n  \n      // Mark the view as destroyed.\n      this._isDestroyed = true;\n  \n      /**\n       * @event DOM.View#destroy\n       */\n      this.triggerMethod('destroy');\n  \n      return this;\n    },\n  \n    /**\n     * Serialize the model or collection.\n     *\n     * @public\n     * @instance\n     * @abstact\n     * @method serializeData\n     * @memberOf DOM.View\n     * @return {Object} - The serialized data.\n     */\n    serializeData() {\n      if (this.model) {\n        return this.serializeModel(this.model);\n      } else if (this.collection) {\n        return this.serializeCollection(this.collection);\n      }\n    },\n  \n    /**\n     * Serialize a model.\n     *\n     * @public\n     * @instance\n     * @abstact\n     * @method serializeModel\n     * @memberOf DOM.View\n     * @param {Model} model - The model to serialize.\n     * @return {Object} - The serialized model.\n     */\n    serializeModel(model) {\n      return _.clone(model.attributes);\n    },\n  \n    /**\n     * Serialize a collection.\n     *\n     * @public\n     * @instance\n     * @abstact\n     * @method serializeCollection\n     * @memberOf DOM.View\n     * @param {Collection} collection - The collection to serialize.\n     * @return {Array} - The serialized collection.\n     */\n    serializeCollection(collection) {\n      return {\n        items: _.map(collection.models, this.serializeModel, this)\n      };\n    },\n  \n    /**\n     * Checks if view is rendered.\n     *\n     * @public\n     * @instance\n     * @method isRendered\n     * @memberOf DOM.View\n     * @return {Boolean} - `true` if the view is rendered, else `false`.\n     */\n    isRendered() {\n      return this._isRendered === true;\n    },\n  \n    /**\n     * Checks if view is destroyed.\n     *\n     * @public\n     * @instance\n     * @method isDestroyed\n     * @memberOf DOM.View\n     * @return {Boolean} - `true` if the view is destroyed, else `false`.\n     */\n    isDestroyed() {\n      return this._isDestroyed === true;\n    },\n  \n    /**\n     * Checks if view is attached.\n     *\n     * @public\n     * @instance\n     * @method isAttached\n     * @memberOf DOM.View\n     * @return {Boolean} - `true` if the view is attached, else `false`.\n     */\n    isAttached() {\n      return this._isAttached === true;\n    }\n  });\n  \n  _.mixin({\n  \n    /**\n     * Checks if `value` is a DOM View.\n     *\n     * ```js\n     * _.isView(View.extend(...));\n     * // >> true\n     * _.isView(new View());\n     * // >> true\n     * _.isView(function() {...});\n     * // >> false\n     * _.isView({...});\n     * // >> false\n     * ```\n     *\n     * @public\n     * @method isClass\n     * @memberOf _\n     * @param {*} value - The value to check.\n     * @return {Boolean} - `true` if the `value` is a view, else `false`.\n     */\n    isView(value) {\n      return !!value && (value instanceof Backbone.View || value.prototype instanceof Backbone.View);\n    }\n  });\n  \n  return DOM;\n});\n"],"sourceRoot":"/source/"}